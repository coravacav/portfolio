---
title: 'The ideal computer science curriculum'
description: A relatively fleshed out computer science curriculum
draft: false
---

# Stefan's relatively fleshed out computer science curriculum

This post is mostly a reaction to failures I see in my own and my peer's education at The University of Utah.
Anecdotally, other cases should be similar and should apply.

### Summary:

| Semester | Courses                                                                               |
| -------- | ------------------------------------------------------------------------------------- |
| 1        | Computer familiarity and research                                                     |
| 2        | Fundamentals of Programming                                                           |
| 3        | Programming language exploration, Computer Architecture, Software in Computer Science |
| 4        | Low Level Programming Details, Applications 1                                         |
| 5        | Data structures, Applications 2, Documentation                                        |
| 6        | Performance, OSes and Memory Security, Application Security                           |
| 7        | Capstone 1, Computer Networks, Elective                                               |
| 8        | Capstone 2, Elective, Elective                                                        |

![Class dependency diagram](/class_diagram.png 'Class dependency diagram')

## Notable failures in no particular order:

### No familiarity with the command line / "how things work"

This isn't referring of course to CPUs as a whole, those are covered fine, but I noticed most never actually get introduced to how their own computer works.
What's a file?
What's the command line?
How do I figure out how to do something?

Basic problem solving.

### Easy passing of "weed out" classes with early group work

In my experience, group works starts too early and makes less desirable pupils continue through this specific education.
I don't believe that believes that everyone who should be learning about it need to care, but if they don't, they should be able to put in the work, not rely on others.

### Useless programming classes

Multiple classes proporting to "learn how to design applications" when realistically it's just slightly more tricky programming problems disguised as application design.

### Relearning the basics of multiple languages instead of getting good at any

### No skipping by AP

### Stats, once. Don't make me take it so many times. Please.

### No group work till Application 2

### All autograded tests will be available for students to run locally. No hidden tests.

## First class - Computer familiarity and research

(skippable by special test only)

This class covers fundamentals of a computer. This includes:

### Day 1 - Computer usage basics (yes, really)

#### Basic Mouse Usage

Left click, right click, scroll wheel, middle click, side buttons on mice that have them.

#### Basic Keyboard Usage

Besides the letters, pretty much every key - notably windows key, escape, and some combos.

#### Basic Keyboard Shortcuts

For now probably Windows and Mac based.
Start menu, spotlight, task manager, etc.

- High level differences between different operating systems
- What is a file
- What is a file system
- Practice navigating using a GUI file explorer
- Practice using context menus
- Practice controlling system settings
- Practice opening different applications
- Practice reading errors
- Practice reading documentation
  This one is interesting, because I think you could really get some value out of showing some error messages and then having students explain what they should google.
- Practice opening a terminal
- Practice starting applications via terminal
- Basic terminal navigation (multiple oses)
- Practice reading help text
- Text editor vs word processor
- Practice following tutorials
- Practice reading documentation to solve problems
- Inspect some websites

A secondary goal to this class is to get students to stop being afraid to try things.

## Second class - Fundamentals of Programming

(skippable by special test only)

Javascript.

The editing environment would still have some form of the Typescript Language Server, so many problems caught by types will still be caught.

This class covers fundamentals of programming, and well.

- Variables
- References
- Functions
- Loops
- Control flow
- Other boolean logic
- Maps
- Lists
- Organization
- Debugging (print statements)
- Objects (as in anonymous maps)

## Another class - Programming language exploration

This class explores all kinds of programming languages.
It teaches how they're used, why they're used, some history, some examples, and performance characteristics.

Notable inclusions:

- C
- Rust
- C++
- Java/C#
- Erlang/Elixir
- Racket/Lisp
- Haskell
- Some proof language (I don't have a favorite)
- M (kind of a bit, but I do like it!)

## Another class - Computer Architecture

Assembly

## Another class - Software in Computer Science

- Git (but alone)
- More GUI
- More Terminal

## Another class - Low Level Programming Details

C / Zig, probably.

Actually show a debugger for the first time.

## Another class - Data structures

Javascript.

## Another class - OSes and Memory Security

- Syscalls
- Linux specifics
- Windows specifics

## Another class - Computer Networks

## Another class - Applications 1

- Databases
- "Web" applications

## Another class - Applications 2

- Capstone esque "next feature" design progress based on Applications 1 project.
- Group work
- Git (but used with others)

## Another class - Documentation

This class counts towards the writing requirement.

## Another class - Performance

## Another class - Application Security

## Electives

Pick 3 ish? Most things became required.

- Computer Graphics
- Compiler
- AI / etc.
- Native applications
- Mobile app
- Others I forget, maybe "deeper dives" into certain covered topics

## Other required classes

- CS 2100
- CS 3100
- Linear algebra (including vector calculus)
- Calculus (2d, 3d, derivatives, integrals, series, optimization)
- Stats, once.

Haven't thought about these enough to be specific, probably never will, don't care enough.

Not necessary to be a good programmer, but necessary for the "science".

## FAQ

### Why Javascript for most of the classes?

For better or for worse, Javascript does the best at three qualities today:

- Coming preinstalled with nearly no way to fuck it up (a web browser)
- Powering most new written applications
- Not going anywhere anytime soon.

Almost everything besides systems level programming can be done in Javascript, effectively too.
Take for example Algorithms.
They can all be done to adequately affect and improve the runtime of a program in Javascript.
They're not as efficient, sure, but, that's not the point.
Nobody teaches best practices for implementation efficiency.

Measure performance first anyway.
